<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backtracking</title>
    <style>
        #first {
            background-color: #FFFFFF;
            
        }
    </style>
</head>
<body>
    <div id="main">
        <!-- < id="first"> -->
            <br><br><br><br>
            <h1>Backtracking</h1>
            <div>
                <p>Backtracking is a form of recursion.</p>
                <p>The usual scenario is that you are faced with a number of options, and you must choose one of these. After you make your <br>
                     choice you will get a new set of options; just what set of options you get depends on what choice you made. This procedure is<br>
                     repeated over and over until you reach a final state. If you made a good sequence of choices, your final state is a goal state; if<br>
                     you didn't, it isn't.
                </p>
                <p>
                    Conceptually, you start at the root of a tree; the tree probably has some good leaves and some bad leaves, though it may be that<br>
                    the leaves are all good or all bad. You want to get a good leaf. At each node, beginning with the root, you choose one of its<br>
                    children to move to, and you keep this up until you get to a leaf.
                </p>
                <p>
                    Suppose you get to a bad leaf. You can backtrack to continue the search for a good leaf by revoking your most recent choice,<br>
                    and trying out the next option in that set of options. If you run out of options, revoke the choice that got you here, and try<br>
                    another choice at that node. If you end up at the root with no options left, there are no good leaves to be found.
                </p><br>                       
                <p>
                    This needs an example.
                </p>
                <img src="./Image_root.png" alt="root_Image"><br>
                <div id="image_ol">
                    <ol id="FirstList" type="1">
                        <li>Starting at root, your options are A and B. You choose A.</li>
                        <li>At A, your options are A and D. You choose C.</li>
                        <li>C is bad. Go back to A.</li>
                        <li>At A, you have already</li>
                        <li>D is bad. Go back to A.</li>
                        <li>At A, you have no options left to try. Go back to Root.</li>
                        <li>At Root, you have already tried A. Try B.</li>
                        <li>At B, your options are E and F. Try E.</li>
                        <li>E is good. Congratulations!</li>
                        
                    </ol>
                </div><br>
                <div id="afterfirstol">
                    <p>In this example we drew a picture of a tree. The tree is an abstract model of the possible sequences of choices we could<br>
                         make. There is also a data structure called a tree, but usually we don't have a data structure to tell us what choices we<br>
                         have. (If we do have an actual tree data structure, backtracking on it is called depth-first tree searching.)
                    </p>
                </div><br>
                <hr><br>
                <div id="backtracking_algo">
                    <h2>The backtracking algorithm.</h2>
                    <div id="code1">
                        <pre>       boolean solve (Node n) {

        if n is a leaf node { 

            if the leaf is a goal node, return true
                            
            else return false
                            
        } else {
                            
            for each child cof n {
                            
                if solve(c) succeeds, return true

            }

        return false

        }

    }
                        </pre>
                    </div>
                </div>
            </div><br>
            <div id="afterfirstcode">
                <p>Notice that the algorithm is expressed as a boolean function. This is essential to understanding the algorithm. If<br>
                    solve(n) is true, that means node n is part of a solution--that is, node n is one of the nodes on a path from the root to<br>
                    some goal node. We say that n is solvable. If solve(n) is false, then there is no path that includes n to any goal node.
                </p>
            </div><br>
            <div id="howdoesthiswork">
                <p>How does it work?</p>
                <ul>
                    <li>If any child of n is solvable, then n is solvable.</li>
                    <li>If no child is solvable, then n is not solvable.</li>
                </ul>
                <br>
                <p>Hence, to decide whether any non-leaf node n is solvable (part of a path to a goal node), all you have to do is test whether any<br>
                     child of n is solvable. This is done recursively, on each child of n. In the above code, this is done by the lines
                </p>
            </div><br>
            <div id="secondcode">
                <pre>       for each child c of n {

        if solve(c) succeeds, return true

      }
        return false
                </pre>
            </div><br>
            <div id="aftersecondcode">
                <p>Eventually the recursion will "bottom" out at a leaf node. If the leaf node is a goal node, it is solvable; if the leaf node is not a goal<br>
                     node, it is not solvable. This is our base case. In the above code, this is done by the lines
                </p>
            </div>
            <div id="thirdcode">
                <pre>       if n is a leaf node {

        if the leaf is a goal node, return true

        else return false

       }
                </pre>
            </div><br>
            <div id="afterthirdcode">
                <p>This algorithm is simple but important. You should understand it thoroughly. Another way of stating it is as follows.</p>
            </div><br>
            <div id="tosearchatree">
                <ul>
                    <li>To search a tree:</li>
                </ul>
                <ol type="1">
                    <li>If the tre has only one node, check if it is the goal node.</li>
                    <li>Otherwise search the whole tree until you find the goal node, or until have<br> searched them all unsuccessfully.</li>
                </ol>
            </div>
            <br>
            <h2>Non recursive backtracking, using a stack</h2>
            <div id="aftrusingastack">
                <p>Backtracking is a rather typical recursive algorithm, and any recursive algorithm can be rewritten as a stack algorithm. In fact<br>
                     that is how your recursive algorithms are translated into machine or assembly language.
                </p>
                <br>
                <pre>
        boolean solve(Node n) {

         put node n on the stack;
                        
          while the stack is not empty {
                        
           if the node at the top of the stack is a leaf {
                        
            if it is a goal node, return true
                        
             else pop it off the stack
                        
          else {
                        
           if the node at the top of the stack has untried children

             push the next untried child onto the stack

           else pop the node off the stack


          }
                        
         return false

        }
                </pre>
            </div><br>
        <div id="startingfromtheroot">
            <p>
                Starting from the root, the only nodes that can be pushed onto the stack are the children of the node currently on the top of the<br>
                stack, and these are only pushed on one child at a time, nence, the nodes on the stack at all times describe a valid path in the<br>
                tree. Nodes are removed from the stack only when it is known that they have no goal nodes among their descendents. Therefore,<br>
                If the root node gets removed (making the stack empty), there must have been no goal nodes at all, and no solution to the<br>
                problem.
            </p>
            <p>
                When the stack algorithm terminates successfully, the nodes on the stack form (in reverse order a path from the root to a goal<br>
                node.
            </p>
            <p>
                Similarly, when the recursive algorithm finds a goal node, the path information is embodied (in reverse order) in the sequence of<br>
                recursive calls. Thus as the recursion unwinds, the path can be recovered one node at a time, by (for instance) printing the node<br>
                at the current level, or storing it in an array
            </p>
            <p>Here is the recursive backtracking algorithm, modified slightly to print (in reverse order) the nodes along the successful path:</p>
        </div><br>
        <div id="fifthcode">
            <pre>       boolean solve(Node n) {

        if n is a leaf node { 
            
         if the leaf is a goal node {
                
          print n
          
          return true

         }
                
         else return false
                
        } else {
                
          for each child c of n {
                
           if solve(c) succeeds {
                
            print n 
            
            return true

           }

          }
                
           return false
        
         }

        }
        </pre>
        </div>
        <div id="keepbacktackingsimple">
            <h2>Keeping backtacking simple</h2>
            <p>
                All of these versions of the backtracking algorithm are pretty simple, but when applied to a real problem, they can get pretty<br>
                cluttered up with details. Even determining whether the node is a leaf can be complex:
            </p>
            <p>
                for example, if the path represents a series of moves in a chess endgame problem, the leaves are the checkmate and stalemate<br>
                solutions
            </p>
            <p>
                To keep the program clean, therefore, tests like this should be buried in methods. In a chess game, for example, you could test<br>
                whether a node is a leaf by writing a <strong>gameOver method</strong>  (or you could even call it <strong>isLeaf).</strong> This method would encapsulate all the<br>
                ugly details of figuring out whether any possible moves remain.
            </p>
            <p>
                Notice that the backtracking attorithms require us to keep track, for each node on the current path, which of its children have<br>
                been tried already (so we don't have to try them again). In the above code we made this look simple; by just saying <strong>for each child<br>
                c of n.</strong>  In reality, it may be difficult to figure out what the possible children are, and there may be no obvious way to step through<br>
                them. In chess, for example, a node can represent one arrangement of pieces on a chessboard, and each child of that node can<br>
                represent the arrangement after some plece has made a legal move How do you find these children, and how do you keep track<br>
                of which ones you've already examined?
            </p>
            <p>
                The most straightforward way to keep track of which children of the node have been tried is as follows. Upon initial entry to the<br>
                node (that is, when you first get there from above), make a list of all its children. As you try each child, take it off the list. When<br>
                the list is empty, there are no remaining untried children, and you can return "fallure. This is a simple approach but it may require<br>
                quite a lot of additional work.
            </p>
            <p>
                There is an easier way to keep track of which children have been tried, if you can define an ordering on the children if there is an<br>
                ordering, and you know which child you just tried, you can determine which child to try next.
            </p>
            <p>
                For example, you might be able to number the <strong>children 1 through n,</strong> and try them in numerical order. Then, if you have just tried<br>
                <strong>child k,</strong> you know that you have already tried children 1 through <strong>k-1,</strong> and you have not yet tried children <strong>k+1</strong> through <strong>n.</strong> Or, if you <br>
                are trying to color a map with just four colors, you can always try <strong>red first, then yellow, then green, then blue.</strong> If child yellow fails,<br>
                you know to try child green next. If you are searching a maze, you can try choices in the order left, straight, right <strong>(or perhaps<br>
                north, east, south, west).</strong>
            </p>
            <p>
                It isn't always easy to find a simple way to order the children of a node. <strong>In the chess game example,</strong> you might number your<br>
                pieces (or perhaps the squares of the board) and try them in numerical order, but in addition each piece may also have several<br>
                moves, and these must also be ordered.
            </p>
        </div>
        <div id="treeSearch">
            <h2>Example: Tree Search</h2>
            <p>
                For starters, let's do the simplest possible example of backtracking, which is searching an actual tree. We will also use the<br>
                simplest kind of tree, a binary tree.
            </p>
            <p>
                A binary tree is a data structure composed of nodes. One node is designated as the root node. Each node can reference (point<br>
                to) zero, one, or two other nodes, which are called its children. The children are referred to as the left child and/or the right child.<br>
                All nodes are reachable (by one or more steps) from the root node, and there are no cycles: For our purposes, although this is not<br>
                part of the definition of a binary tree, we will say that a node might or might not be a goal node, and will contain its name. The <br>
                first example in this paper which we repeat here) shows a binary tree.
            </p>
            <p>
                Here's a defination of the binaryTree class:
            </p>
        </div>
        <div id="binaryTreeclass">
            <pre>
                public class binaryTree {

                    BinaryTree leftChild = null;

                    BinaryTree rightChild = null;

                    boolean isGoalNode = false;

                    String name;


                  BinaryTree(String name, BinaryTree left, BinaryTree right, boolean isGoalNode) {

                    this.name = name;

                    leftChild = left;

                    rightChild = right;

                    this.isGoalNode = isGoalNode;

                  }

                }
            </pre><br>
            <p>
                Next we will create a TreeSearch class, and in it we will define a method makeTree() which constructs the above binary tree.
            </p><br>
            <div id="staticBinaryTree">
                <pre>
       static Binary Tree makeTree() {

        Binary Tree rool, a, b, c, d, e, f;

         c = new Binary Treel C, null, null, false);

         d = new BinaryTree("D", null, null, false);

         e = new Binary Treet E, null, null, true);

         f = new Binary Tree("F", null, null, false);

         a = new BinaryTree("A", c, d, false); 

         b= new Binary Tree("B" e, false); 

         root new BinaryTree Root, a, b, false); 

         return root;

       }
                        
                </pre>
            </div>

        </div>
        <br>
        <div id="mainprogramtocreatebinarytree">
            <p>
                Here is a main program to create a binary tree and try to solve it:
            </p><br>
            <div id="programtocreatebinarytree">
                <pre>
        public static void main(String args[]) {

            BinaryTree tree = makeTree();

            System.out.println(solvable(tree));

        }
                </pre>
            </div>
        </div><br>
        <div id="recursivebacktracking">
            <p>
                And finally, here's the recursive backtracking routine to "solve" the binary tree by finding a goal node.
            </p>
            <div id="recursiveBacktrackingCode">
                <pre>
        static boolean solvable(BinaryTree node) { 

        /* 1 */ if (node == null) return false; 

        /* 2 */ if (node.isGoalNode) return true;

        /* 3 */ if (solvable(node.leftChild)) return true; 

        /* 4 */ if (solvable(node.rightChild)) return true; 

        /* 5 */ return false; 

        }
                </pre>
            </div>
        </div>
        <br>
        <div id="discriptionofnumberedlines">
            <p>Here's what the numbered lines are doing:</p>
            <ol>
                <li>
                    If we are given a null node, it's not solvable. This statement is so that we can call this method with the children of a node, without<br>
                    first checking whether those children actually exist.
                </li>
                <li>
                    If the node we are given is a goal node, return success.
                </li>
                <li>
                    See if the left child of node is solvable, and if so, conclude that node is solvable. We will only get to this line if node is non-null<br>
                    and is not a goal node, says to
                </li>
                <li>
                    Do the same thing for the right child.
                </li>
                <li>
                    Since neither child of node is solvable, node itself is not solvable.
                </li>
            </ol>
            <p>
                This program runs correctly and produces the unenlightening result true.
            </p>
            <p>
                Each time we ask for another node, we have to check if it is null. In the above we put that check as the first thing in solvable. An<br>
                alternative would be to check first whether each child exists, and recur only if they do. Here's that alternative version:
            </p>
            <br>
            <div id="code">
                <pre>
        static boolean solvable(BinaryTree node) {

          if (node.isGoalNode) return true;
          
          if (node.leftChild != null && solvable(node.leftChild)) return true;

          if (node.rightChild != null && solvable(node.rightChild)) return true;

          return false;

        }
                </pre>
            </div>
            <p>
                I think the first version is simpler, but the second version is slightly more efficient.
            </p>  
        </div>
        <hr>
        <div id="whatarethrchildren?">
            <h2>What are the children?</h2>
            <div>
                <p>
                    One of the things that simplifies the above binary tree search is that, at each choice point, you can ignore all the
                    previous<br> choices. Previous choices don't give you any information about what you should do next; as far as you know,
                    both the left and the<br> right child are possible solutions. In many problems, however, you may be able to eliminate
                    children immediately, without<br> recursion.<br><br><br> Consider, for example, the problem of four-coloring a map. It is a theorem of
                    mathematics that any map on a plane, no matter<br> how convoluted the countries are, can be colored with at most four
                    colors, so that no two countries that share a border are the<br> same color.<br><br><br> To color a map, you choose a color for the
                    first country, then a color for the second country, and so on, until all countries are<br> colored.<br><br><br> There are two ways to do
                    this:
                </p>
            </div>
        </div>
        <ul>
            <li>
                Method 1. Try each of the four possible colors, and recur. When you run out of countries, check whether you are at a goal node.
            </li><br>
            <li>
                Method 2. Try only those colors that have not already been used for an adjacent country, and recur. If and when you run out of<br> countries, you have successfully colored the map.
            </li>
        </ul><br>
        <p>
            Let's apply each of these two methods to the problem of coloring a checkerboard. This should be easily solvable; after all, a<br>
            checkerboard only needs two colors.
        </p>
        <div id="booleanmapisOK">
            <p>
                <strong>boolean mapIsOK()</strong><br>
                Used by method 1 to check (at a leaf node) whether the entire map is colored correctly.
                <br><br><br>
                <strong>boolean okToColor(int row, int column, int color)</strong><br>
                Used by method 2 to check, at every node, whether there is an adjacent node already colored with the given color.<br><br>
                <br>
                <strong> int[] nextRowAndColumn(int row, int column)</strong><br>
                <br>
                Used by both methods to find the next "country" (actually, the row and column of the next square on the checkerboard).
            </p>
            <br><br>
            <p>
                Here's the code for method 1:
            </p><br>
            <div id="codeformethod1">
                <pre>
        boolean explore1(int row, int column, int color) { 

         if (row >= NUM_ROWS)return mapIsOK();

         map[row][column] = color; 

         for (int nextColor = RED; nextColor <= BLUE; nextColor++) {

          int[] next = nextRowAndColumn(row, column);

          if (explore1(next[0], next[1], nextColor)) return true;

         }

         return false;

        }
                </pre>
            </div><br><br>
        </div>
        <p>
            And here's the code for method 2:
        </p>
        <br>
        <div id="codeformethod2">
            <pre>
        boolean explore2(int row, int column, int color) {

         if (row >= NUM_ROWS)return true;

         if (okToColor(row, column, color)) {

          map[row][column] = color;

          for (int nextColor = RED; nextColor <= BLUE; nextColor++) {

            int[] next = nextRowAndColumn(row, column);

            if (explore2(next[0], next[1], nextColor)) return true;

          }

         }

         return false;

        }
            </pre><br><br>
            <p>
                Those appear pretty similar, and you might think they are equally good. However, the timing information suggests otherwise:
            </p>
        </div>
        <br>
        <div id="firsttable">
            <table align="center" border="1">
                <tr>
                    <th></th>
                    <th style="background-color: #D3D3D3;">2 by 3 map</th>
                    <th style="background-color: #D3D3D3;">3 by 3 map</th>
                    <th style="background-color: #D3D3D3;">3 by 4 map</th>
                </tr>
                <tr>
                    <td style="background-color: #D3D3D3;">Method 1:</td>
                    <td>60 ms.</td>
                    <td>940 ms.</td>
                    <td>60530 ms. (1 minute)</td>
                </tr>
                <tr>
                    <td style="background-color: #D3D3D3;">Method 2:</td>
                    <td>0ms.</td>
                    <td>0 ms.</td>
                    <td>0 ms</td>
                </tr>
            </table><br>
            <p>
                The zeros in the above table indicate times too short to measure (less than 1 millisecond). Why this huge difference? Either of<br>
                these methods could have exponential growth. Eliminating a node automatically eliminates all of its descendents, and this will<br>
                often prevent exponential growth. Conversely, by waiting to check until a leaf node is reached, exponential growth is practically<br>
                guaranteed. If there is any way to eliminate children (reduce the set of choices), do so!
            </p><br>
            <hr>
        </div><br>
        <div id="debuggingTechniques">
            <h2>Debugging Techniques</h2>
            <p>
                Often our first try at a program doesn't work, and we need to debug it. Debuggers are helpful, but sometimes we need to
                fall<br> back on inserting print statements. There are some simple tricks to making effective use of print statements. These
                tricks can be<br> applied to any program, but are especially useful when you are trying to debug recursive routines.
            </p>
        </div><br>
        <div id="Trick1">
            <p>
                <b>Trick #1: Indent when you print method entries and exits.</b><br><br><br>
                Often, the best debugging technique is to print every method call and return (or at least the most important ones). You
                probably<br> want to print, for each method, what parameters it came in with, and what value it leaves with. However, if you
                just print a long<br> list of these, it's hard to match up method exits with their corresponding entries. Indenting to show
                the level of nesting can help.
            </p>
        </div><br>
        <div id="Trick2">
            <p>
                <b>Trick #2: Use specialized print methods for debugging.</b><br><br><br>
                Don't clutter up your actual code more than you must. Also, remember that code inserted for debugging purposes can
                itself<br> contain bugs, or (in the worst case) can affect the results, so be very careful with it.
            </p>
            <p>
                Here's our debugging code. For this trivial program, there's almost more debugging code than actual code, but in larger
                programs<br> the proportions will be better.
            </p>
        </div><br>
        <div id="trick2code">
            <pre>
        static String indent = "";
        
         
        static String name(BinaryTree node) {

          if (node == null) return null;

          else return node.name;

        }


        static void enter(BinaryTree node) {

          System.out.println(indent + "Entering solvable(" + name(node) + ")");

          indent = indent + "| ";
          
        }


        static boolean yes(BinaryTree node) {

          indent = indent.substring(3);

          System.out.println(indent + "solvable(" + name(node) + ") returns true");

          return true;

        }


        static boolean no(BinaryTree node) {

          indent = indent.substring(3);

          System.out.println(indent + "solvable(" + name(node) + ") returns false"); 

          return false;

        }
            </pre>
            <br><br>
        </div>
        <p>To use this code, we modify solvable as follows:</p><br><br>
        <div id="modifySolvable">
            <pre>
        static boolean solvable(BinaryTree node) {

            enter(node);

            if (node == null) return no(node);

            if (node.isGoalNode) return yes(node); 

            if (solvable(node.leftChild)) return yes(node);

            if (solvable(node.rightChild)) return yes(node);

            return no(node); 

        }
            </pre>
        </div><br><br>
        <p>And we get these results:</p><br>
        <div id="results">
            <pre>
    Entering solvable(Root)

    | Entering solvable(A) 

    | | Entering solvable(C)

    | | | Entering solvable(null)

    | | | solvable(null) returns false

    | | | Entering solvable(null)

    | | | solvable(null) returns false

    | | solvable(C) returns false

    | | Entering solvable(D)

    | | | Entering solvable(null)

    | | | solvable(null) returns false 

    | | | Entering solvable(null)

    | | | solvable(null) returns false

    | | solvable(D) returns false

    | solvable(A) returns false

    | Entering solvable(B)

    | | Entering solvable(E)

    | | solvable(E) returns true

    | solvable(B) returns true

    solvable(Root) returns true

    true
            </pre>
        </div><br><br>
        <div id="trick3">
            <b>Trick #3: Never discard your debugging statements.</b>
            <p>
                Writing debugging statements is programming, too. Often it's as much work to debug the debugging statements as it is to
                debug<br>
                the actual program. Once your program is working, why throw this code away?<br>
                <br><br> Obviously, you don't want to print out
                all this debugging information from a program you are ready to submit (or to turn over to<br> your manager). You could
                comment out your debugging calls, but that can be a lot of work. What's more, in the above example,<br> you would have to
                replace every return(yes(node)) with return(true), and every return(no(node)) with return false. With all these<br> changes,
                you might introduce new bugs into your program.<br><br><br> The simple solution is to make your debugging statements conditional.
                For example,
            </p><br><br>
            <div id="trick3code">
                <pre>
        static final boolean debugging = false;


        static void enter(BinaryTree node) { 

          if (debugging) {

            System.out.println(indent + "Entering solvable(" + name(node) + ")") ;

            indent = indent + "| "; 

          }

        }


        static boolean yes(BinaryTree node) {

          if (debugging) {

            indent = indent.substring(3);
            
            System.out.println(indent + "solvable(" + name(node) + ") returns true");

          }

          return true;

        }


        static boolean no(BinaryTree node) {

          if (debugging) {
            
            indent = indent.substring(3);

            System.out.println(indent + "solvable(" + name(node) + ") returns false");

          }

          return false;

        }
                </pre>
            </div>
            <div id="para1beforetrick4">
                <p>
                    In industry, actual programs often have multiple flags to control different aspects of debugging. Don't worry too much
                    about<br>
                    making your code larger; modern compilers will notice that since the variable debugging is final, it can never be
                    true, and the<br> controlled code will be discarded.
                </p>
            </div>
        </div><br><br>
        <div id="trick4">
            <h2>Trick #4: Create an Exception</h2><br>
            <p>
                If an Exception is thrown, you can get information about just where it happened by sending it the message
                <br>printStackTrace(PrintStream). Since an Exception is an object like any other, you can create and throw your own
                Exceptions.<br> However, Java programmers don't always realize that you can create an Exception without throwing it. For
                example, the following code
            </p><br>
            <div id="trick4code1">
                <pre>
        new Exception("Checkpoint Charlie").printStackTrace(System.out);
                </pre>
            </div><br>
            <div id="aftertrick4code1">
                <p>
                    will print out a message something like this, and the program will then continue normally. That is, the above code just
                    acts like a <br>print statement.
                </p>
            </div>
            <div id="trick4code2">
                <pre>
        java.lang.Exception: Checkpoint Charlie
                    
            at TreeSearch.solvable(TreeSearch.java:53)
        
            at TreeSearch.solvable(TreeSearch.java:57) 

            at TreeSearch.main(TreeSearch.java:72) 

            at __SHELL38.run(__SHELL38.java:16)

            at bluej.runtime.ExecServer.suspendExecution(Unknown Source)
        
                </pre>
            </div><br><br><hr>
            <br><br>
        </div>
        <div id="exampcindypuzzle">
            <p>
                I call the following puzzle "Cindy's puzzle" for historical reasons. You have some number n of black marbles and the
                same number<br> of white marbles, and you have a playing board which consists simply of a line of 2n+1 spaces to put the
                marbles in. Start with<br> the black marbles all at one end (say, the left), the white marbles all at the other end, and a
                free space in between.
            </p><br>
            <table align="center" border="1" style= "background-color: #D3D3D3">
                <tr>
                    <td width = "50px"> <img src="./Images/black-ball.png" alt=""></td>
                    <td width = "50px"><img src="./Images/black-ball.png" alt=""></td>
                    <td width = "50px"></td>
                    <td width = "50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                    <td width = "50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                </tr>
            </table>
            <br>
            <p>The goal is to reverse the position of the marbles:</p><br>
            <table align="center" border="1">
                <tr>
                    <td width = "50px"> <img src="./Images/black-ball.png" alt=""></td>
                    <td width = "50px"><img src="./Images/black-ball.png" alt=""></td>
                    <td width = "50px"></td>
                    <td width = "50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                    <td width = "50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                </tr>
            </table><br><br>
            <p>
                The black marbles can only move to the right, and the white marbles can only move to the left (no backing up). At each
                move, a<br> marble can either:
            </p><br>
            <ul>
                <li>
                    Move one space ahead, if that space is clear, or
                </li>
                <li>Jump ahead over exactly one marble of the opposite color, if the space just beyond that marble is clear.</li>
            </ul><br>
            <p>
                For example, you could make the following sequence of moves:
            </p>
            <br>
            <div>
                <!-- <p><strong>Starting Position &nbsp;:</strong></p> -->
                <!-- <table align="center" border="1">
                    <tr>
                        <th>Starting Position &nbsp;</th>
                        <td>
                            <table>
                                <tr>
                                    <td><img src="./Images/white-ball.png"></td>
                                    <td><img src="./Images/white-ball.png"></td>
                                    <td style="width: 45px;"></td>
                                    <td><img src="./Images/black-ball.png"></td>
                                    <td><img src="./Images/black-ball.png"></td>
                                </tr>
                            </table>
                        </td>
                        <!-- <th><img src="./Images/white-ball.png"></th>
                        <th><img src="./Images/white-ball.png"></th>
                        <th style="width: 45px;"></th>
                        <th><img src="./Images/black-ball.png"></th>
                        <th><img src="./Images/black-ball.png"></th> -->
                     </tr>
                </table>    
                <center>
                    <table>
                        <tr>
                            <th>Starting Position &nbsp;</th>
                            <td>
                                <table border="1px">
                                    <tr>
                                        <td width = "50px"> <img src="./Images/black-ball.png" alt=""></td>
                                        <td width = "50px"><img src="./Images/black-ball.png" alt=""></td>
                                        <td width = "50px"></td>
                                        <td width = "50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                                        <td width = "50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                                    </tr>
                                </table>
                            </td>
                        </tr><br><br>
                        <tr>
                            <th>Black moves ahead &nbsp;</th>
                            <td>
                                <table border="1px">
                                    <tr>
                                        <td width="50px"> <img src="./Images/black-ball.png" alt=""></td>
                                        <td width="50px"></td>
                                        <td width="50px"><img src="./Images/black-ball.png" alt=""></td>
                                        <td width="50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                                        <td width="50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                                    </tr>
                                </table>
                            </td>
                        </tr><br>
                        <tr>
                            <th>White jumps &nbsp;</th>
                            <td>
                                <table border="1px">
                                    <tr>
                                        <td width="50px"> <img src="./Images/black-ball.png" alt=""></td>
                                        <td width="50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                                        <td width="50px"><img src="./Images/black-ball.png" alt=""></td>
                                        <td width="50px"></td>
                                        <td width="50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                                    </tr>
                                </table>
                            </td>
                        </tr><br>
                        <tr>
                            <th>Black moves ahead: &nbsp;</th>
                            <td>
                                <table border="1px">
                                    <tr>
                                        <td width="50px"> <img src="./Images/black-ball.png" alt=""></td>
                                        <td width="50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                                        <td width="50px"></td>
                                        <td width="50px"><img src="./Images/black-ball.png" alt="Black"></td>
                                        <td width="50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                                    </tr>
                                </table>
                            </td>
                        </tr><br>
                        <tr>
                            <th>Black jumps: &nbsp;</th>
                            <td>
                                <table border="1px">
                                    <tr>
                                        <td width="50px"></td>
                                        <td width="50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                                        <td width="50px"><img src="./Images/black-ball.png" alt="Black"></td>
                                        <td width="50px"><img src="./Images/black-ball.png" alt="Black"></td>
                                        <td width="50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                                    </tr>
                                </table>
                            </td>
                        </tr><br><br>
                        <tr>
                            <th>White moves ahead: &nbsp;</th>
                            <td>
                                <table border="1px">
                                    <tr>
                                        <td width="50px"></td>
                                        <td width="50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                                        <td width="50px"><img src="./Images/black-ball.png" alt="Black"></td>
                                        <td width="50px"><img src="./Images/black-ball.png" alt="Black"></td>
                                        <td width="50px"><img src="./Images/white-ball.png" alt="white_ball"></td>
                                    </tr>
                                </table>
                            </td>
                        </tr><br>
                    </table>
                </center>   
                <p><strong>Stuck!</strong></p>
            </div>
        </div><br><br>
        <div id="afterpuzlepara">
            <p>
            The backtracking method is named solvable and returns a boolean. In solvable we shall need to check whether we are at a
            leaf, <br>which in this case means a position from which no further moves are possible. This isn't so easy.<br><br><br> Now to the
            program. The main program will initialize the board, and call a recursive backtracking routine to attempt to solve the
            <br> puzzle. The backtracking routine will either succeed and print out a winning path, or it will fail, and the main program
            will have to<br> print out the bad news.<br><br><br> The backtracking method is named solvable and returns a boolean. In solvable we
            shall need to check whether we are at a leaf,<br> which in this case means a position from which no further moves are
            possible. This isn't so easy.<br><br><br> Each possible move will result in a new board position, and these new board positions are
            the children of the current board<br> position. Hence to find the children of a node (that is, of a board position), we need
            only find the possible moves from that node.<br> Remember that it is also highly desirable to find an ordering on these
            possible moves.<br><br><br> Here it is time to stop and take thought. To make progress, we must analyze the game to some extent.
            Probably a number of<br> approaches would work, and what follows is based on the way I worked it out. If you were to program
            this puzzle, you might find<br> a different but equally valid approach.<br><br><br> First, notice that if a marble has a move, that move
            is unique: if it can move ahead one square, then it cannot jump. If it can jump,<br> it cannot move ahead one square. This
            suggests that, to find the possible moves, we might assign numbers to the marbles, and<br> check each marble in turn. When
            we have looked at all the marbles, we have looked at all the possible moves. This would require<br> having a table to keep
            track of where each marble is, or else somehow "marking" each marble with its number and searching the<br> board each time
            to find the marble we want. Neither alternative is very attractive.<br><br><br> Next, notice that for a given board position, each
            marble occupies a unique space. Hence, instead of talking about moving a<br> particular marble, we can talk about moving the
            marble in a particular space. If a move is possible from a given space, then that<br> must be the only move possible from
            that space, because if the marble in that space has a move, it is unique. There is a slight<br> complication because not
            every space contains a marble, but at least the spaces (unlike the marbles) stay in one place.
            </p><br><br>
            <p><b>
                Now we have a simpler ordering of moves to use in our program. Just check, in order, the 2n+1 spaces of the board. For
                each<br> space, either zero or one moves is possible. With this understanding, we can write a boolean method canMove(int[]
                board, int<br> position) which determines whether a move is possible from the given position:
            </b></p><br>
            <ul>
                <li>If the position is empty, no move is possible;</li>
                <li>If the position contains a black marble, the method checks for a move or jump to the right;</li>
                <li>If the position contains a white marble, the method checks for a move or jump to the left.</li>
            </ul>
            <div id="beforelastcode">
                <p>
                    We write another method <strong>int[] makeMove(int[] oldBoard, int position)</strong> that will take a board and a position, make a move
                    from<br> that position, and return as its value a new board. (We could write this somewhat more efficiently by changing the
                    old board, <br>rather than creating a new one, but here we are more concerned with simplicity.) In technical jargon,
                    makeMove is "applicative"<br> rather than "mutative."<br><br><br> Along with canMove and makeMove, we are using methods puzzleSolved and
                    printBoard with meanings that <br> should be obvious. 
                </p>
            </div>
            <div id="lastcode">
                <pre>
        boolean solvable(int[] board) { 

          if (puzzleSolved(board)) { 

            return true;

          }

          for (int position = 0; position < BOARD_SIZE; position++) { 

           if (canMove(board, position)) {  
            
            int[] newBoard = makeMove(board, position);

            if (solvable(newBoard)) {

             printBoard(newBoard);    

             return true; 

             }

           }

         }
        return false;

       }
            </div>
        </div>
        <div id="lastpara">
            <p>
                Along with canMove and makeMove, we are using methods puzzleSolved and printBoard with meanings that should be obvious.
                <br><br><br> Here is some output from the program:
            </p>
            <div id="boldtag">
                <ol start="14" type="1" reversed>
                    <li><strong> WHITE WHITE WHITE ______ BLACK BLACK BLACK</strong></li>
                    <li><strong> WHITE WHITE WHITE BLACK ______ BLACK BLACK</strong></li>
                    <LI><strong> WHITE WHITE ______ BLACK WHITE BLACK BLACK</strong></LI>
                    <li><strong> WHITE ______ WHITE BLACK WHITE BLACK BLACK</strong></li>
                    <li><strong> WHITE BLACK WHITE ______ WHITE BLACK BLACK</strong></li>
                    <li><strong> WHITE BLACK WHITE BLACK WHITE ______ BLACK</strong></li>
                    <li><strong> WHITE BLACK WHITE BLACK WHITE BLACK ______</strong></li>
                    <li><strong> WHITE BLACK WHITE BLACK ______ BLACK WHITE</strong></li>
                    <li><strong> WHITE BLACK ______ BLACK WHITE BLACK WHITE</strong></li>
                    <li><strong> ______ BLACK WHITE BLACK WHITE BLACK WHITE</strong></li>
                    <li><strong> BLACK ______ WHITE BLACK WHITE BLACK WHITE</strong></li>
                    <li><strong> BLACK BLACK WHITE ______ WHITE BLACK WHITE</strong></li>
                    <li><strong> BLACK BLACK WHITE BLACK WHITE ______ WHITE</strong></li>
                    <li><strong> BLACK BLACK BLACK ______ WHITE WHITE WHITE</strong></li>
                </ol>
            </div>
            <br>
            <p>
                Notice that the solution is given in reverse order: BLACK starts out on the left and WHITE on the right, as in the last
                 I've added<br> line numbers to the actual output in order to emphasize this point. Backtracking always produces its
                <br> results (sequence of choices) in reverse order; it is up to you, the programmer, to reverse the results again to get
                <br>them in the correct order.
            </p>
        </div>
        </div>
    </div>
</body>
</html>
